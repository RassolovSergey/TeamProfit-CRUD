@inject HttpClient Http

@if (IsVisible)
{
    <div class="modal-overlay">
        <div class="modal">
            <h3>@(IsEdit ? "Редактировать узел" : "Создать узел")</h3>
            <EditForm Model="editModel" OnValidSubmit="HandleValidSubmit">
                <DataAnnotationsValidator />
                <ValidationSummary />
                <div class="form-group">
                    <label>Название</label>
                    <InputText @bind-Value="editModel.Name" class="form-control" />
                </div>
                <div class="form-group">
                    <label>Тип узла</label>
                    <InputText @bind-Value="editModel.NodeType" class="form-control" disabled="@IsEdit" />
                </div>
                <div class="form-group">
                    <label>ID родителя</label>
                    <InputNumber @bind-Value="editModel.ParentId" class="form-control" />
                </div>
                <button type="submit" class="btn btn-primary">Сохранить</button>
                <button type="button" class="btn btn-secondary" @onclick="Close">Отмена</button>
            </EditForm>
        </div>
    </div>
}

@code {
    // Параметр, определяющий видимость диалога
    [Parameter] public bool IsVisible { get; set; }
    [Parameter] public EventCallback<bool> IsVisibleChanged { get; set; }
    // Если передана модель, значит редактирование, иначе – создание нового узла
    [Parameter] public TreeNodeDto Model { get; set; }
    // Callback для оповещения о сохранении (можно обновить дерево)
    [Parameter] public EventCallback<TreeNodeDto> OnSave { get; set; }

    private bool IsEdit => Model != null;
    private TreeNodeDto editModel = new TreeNodeDto();

    protected override void OnParametersSet()
    {
        if (IsEdit)
        {
            // Клонируем переданный объект, чтобы изменения не затрагивали исходный до сохранения
            editModel = new TreeNodeDto
                {
                    Id = Model.Id,
                    Name = Model.Name,
                    NodeType = Model.NodeType,
                    ParentId = Model.ParentId,
                    ParentType = Model.ParentType,
                    HasChildren = Model.HasChildren
                };
        }
        else
        {
            editModel = new TreeNodeDto();
        }
    }

    // Обработка отправки данных формы
    private async Task HandleValidSubmit()
    {
        if (IsEdit)
        {
            // Вызов API для обновления узла (используем PUT-метод; endpoint "tree/update" уже реализован)
            var response = await Http.PutAsJsonAsync("tree/update", new
            {
                NodeType = editModel.NodeType,
                NodeId = editModel.Id,
                NewParentId = editModel.ParentId
            });
            if (response.IsSuccessStatusCode)
            {
                await OnSave.InvokeAsync(editModel);
            }
        }
        else
        {
            // Предположим, что для создания узла реализован endpoint "tree/create"
            var response = await Http.PostAsJsonAsync("tree/create", editModel);
            if (response.IsSuccessStatusCode)
            {
                var newNode = await response.Content.ReadFromJsonAsync<TreeNodeDto>();
                await OnSave.InvokeAsync(newNode);
            }
        }
        await Close();
    }

    private async Task Close()
    {
        IsVisible = false;
        await IsVisibleChanged.InvokeAsync(IsVisible);
    }
}
