@using Plk.Blazor.DragDrop
@inject HttpClient Http

<Draggable TItem="TreeNodeDto" ItemData="Node" Class="draggable-node">
    <DropZone TItem="TreeNodeDto" OnDrop="HandleDrop" Class="droppable-zone">
        <li>
            <div class="node-container">
                @if (Node.HasChildren)
                {
                    <button @onclick="ToggleChildren">
                        @(expanded ? "−" : "+")
                    </button>
                }
                <span>@Node.Name</span>
                <button @onclick="EditNode">Редактировать</button>
                <button @onclick="DeleteNode">Удалить</button>
            </div>

            @if (expanded)
            {
                @if (children == null)
                {
                    <div>Загрузка...</div>
                }
                else
                {
                    <ul>
                        @foreach (var child in children)
                        {
                            <!-- Рекурсивный вызов для дочерних узлов -->
                            <TheeNodeComponent Node="child" OnNodeChanged="ChildChanged" />
                        }
                    </ul>
                }
            }
        </li>
    </DropZone>
</Draggable>

@code {
    [Parameter] public TreeNodeDto Node { get; set; }
    // Callback для уведомления родительского компонента об изменениях (например, после редактирования или drop)
    [Parameter] public EventCallback OnNodeChanged { get; set; }

    private bool expanded = false;
    private List<TreeNodeDto> children;

    private async Task ToggleChildren()
    {
        expanded = !expanded;
        if (expanded && children == null && Node.HasChildren)
        {
            // Определяем endpoint в зависимости от типа узла
            string endpoint = Node.NodeType.ToLower() switch
            {
                "user" => $"tree/user/{Node.Id}/children",
                "team" => $"tree/team/{Node.Id}/children",
                "project" => $"tree/project/{Node.Id}/children",
                _ => null
            };

            if (endpoint != null)
            {
                children = await Http.GetFromJsonAsync<List<TreeNodeDto>>(endpoint);
            }
        }
    }

    private void EditNode()
    {
        // Здесь можно вызвать модальное окно для редактирования узла
    }

    private async Task DeleteNode()
    {
        // Выполните вызов API для удаления узла, затем обновите дерево
        await OnNodeChanged.InvokeAsync(null);
    }

    /// <summary>
    /// Обработчик события drop, полученного от компонента DropZone.
    /// </summary>
    /// <param name="args">Содержит данные перетаскиваемого узла.</param>
    private async Task HandleDrop(TreeNodeDto draggedNode, DragEventArgs e)
    {
        // draggedNode – это объект, который перетаскивали
        // e – стандартный DragEventArgs для дополнительной информации (если нужно)
        if (draggedNode.NodeType.Equals("User", StringComparison.OrdinalIgnoreCase))
        {
            var dto = new
            {
                NodeType = draggedNode.NodeType,
                NodeId = draggedNode.Id,
                NewParentId = Node.Id  // Новый родитель – это текущий узел (Node)
            };

            // Обновляем родительскую связь
            await Http.PutAsJsonAsync("tree/update-team", dto);
        }

        // Можно добавить аналогичную логику для других типов узлов (Cost, Project и т.д.)
        await OnNodeChanged.InvokeAsync();
    }


    private async Task ChildChanged()
    {
        string endpoint = Node.NodeType.ToLower() switch
        {
            "user" => $"tree/user/{Node.Id}/children",
            "team" => $"tree/team/{Node.Id}/children",
            "project" => $"tree/project/{Node.Id}/children",
            _ => null
        };

        if (endpoint != null)
        {
            children = await Http.GetFromJsonAsync<List<TreeNodeDto>>(endpoint);
            StateHasChanged();
            await OnNodeChanged.InvokeAsync(null);
        }
    }
}
